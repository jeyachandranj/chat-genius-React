{"ast":null,"code":"import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nimport { ERROR_PACKET } from \"./commons.js\";\nvar SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n\nvar encodePayload = function encodePayload(packets, callback) {\n  // some packets may be added to the array while encoding, so the initial length must be saved\n  var length = packets.length;\n  var encodedPackets = new Array(length);\n  var count = 0;\n  packets.forEach(function (packet, i) {\n    // force base64 encoding for binary packets\n    encodePacket(packet, false, function (encodedPacket) {\n      encodedPackets[i] = encodedPacket;\n\n      if (++count === length) {\n        callback(encodedPackets.join(SEPARATOR));\n      }\n    });\n  });\n};\n\nvar decodePayload = function decodePayload(encodedPayload, binaryType) {\n  var encodedPackets = encodedPayload.split(SEPARATOR);\n  var packets = [];\n\n  for (var i = 0; i < encodedPackets.length; i++) {\n    var decodedPacket = decodePacket(encodedPackets[i], binaryType);\n    packets.push(decodedPacket);\n\n    if (decodedPacket.type === \"error\") {\n      break;\n    }\n  }\n\n  return packets;\n};\n\nexport function createPacketEncoderStream() {\n  return new TransformStream({\n    transform: function transform(packet, controller) {\n      encodePacketToBinary(packet, function (encodedPacket) {\n        var payloadLength = encodedPacket.length;\n        var header; // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n\n        if (payloadLength < 126) {\n          header = new Uint8Array(1);\n          new DataView(header.buffer).setUint8(0, payloadLength);\n        } else if (payloadLength < 65536) {\n          header = new Uint8Array(3);\n          var view = new DataView(header.buffer);\n          view.setUint8(0, 126);\n          view.setUint16(1, payloadLength);\n        } else {\n          header = new Uint8Array(9);\n\n          var _view = new DataView(header.buffer);\n\n          _view.setUint8(0, 127);\n\n          _view.setBigUint64(1, BigInt(payloadLength));\n        } // first bit indicates whether the payload is plain text (0) or binary (1)\n\n\n        if (packet.data && typeof packet.data !== \"string\") {\n          header[0] |= 0x80;\n        }\n\n        controller.enqueue(header);\n        controller.enqueue(encodedPacket);\n      });\n    }\n  });\n}\nvar TEXT_DECODER;\n\nfunction totalLength(chunks) {\n  return chunks.reduce(function (acc, chunk) {\n    return acc + chunk.length;\n  }, 0);\n}\n\nfunction concatChunks(chunks, size) {\n  if (chunks[0].length === size) {\n    return chunks.shift();\n  }\n\n  var buffer = new Uint8Array(size);\n  var j = 0;\n\n  for (var i = 0; i < size; i++) {\n    buffer[i] = chunks[0][j++];\n\n    if (j === chunks[0].length) {\n      chunks.shift();\n      j = 0;\n    }\n  }\n\n  if (chunks.length && j < chunks[0].length) {\n    chunks[0] = chunks[0].slice(j);\n  }\n\n  return buffer;\n}\n\nexport function createPacketDecoderStream(maxPayload, binaryType) {\n  if (!TEXT_DECODER) {\n    TEXT_DECODER = new TextDecoder();\n  }\n\n  var chunks = [];\n  var state = 0\n  /* READ_HEADER */\n  ;\n  var expectedLength = -1;\n  var isBinary = false;\n  return new TransformStream({\n    transform: function transform(chunk, controller) {\n      chunks.push(chunk);\n\n      while (true) {\n        if (state === 0\n        /* READ_HEADER */\n        ) {\n          if (totalLength(chunks) < 1) {\n            break;\n          }\n\n          var header = concatChunks(chunks, 1);\n          isBinary = (header[0] & 0x80) === 0x80;\n          expectedLength = header[0] & 0x7f;\n\n          if (expectedLength < 126) {\n            state = 3\n            /* READ_PAYLOAD */\n            ;\n          } else if (expectedLength === 126) {\n            state = 1\n            /* READ_EXTENDED_LENGTH_16 */\n            ;\n          } else {\n            state = 2\n            /* READ_EXTENDED_LENGTH_64 */\n            ;\n          }\n        } else if (state === 1\n        /* READ_EXTENDED_LENGTH_16 */\n        ) {\n          if (totalLength(chunks) < 2) {\n            break;\n          }\n\n          var headerArray = concatChunks(chunks, 2);\n          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n          state = 3\n          /* READ_PAYLOAD */\n          ;\n        } else if (state === 2\n        /* READ_EXTENDED_LENGTH_64 */\n        ) {\n          if (totalLength(chunks) < 8) {\n            break;\n          }\n\n          var _headerArray = concatChunks(chunks, 8);\n\n          var view = new DataView(_headerArray.buffer, _headerArray.byteOffset, _headerArray.length);\n          var n = view.getUint32(0);\n\n          if (n > Math.pow(2, 53 - 32) - 1) {\n            // the maximum safe integer in JavaScript is 2^53 - 1\n            controller.enqueue(ERROR_PACKET);\n            break;\n          }\n\n          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n          state = 3\n          /* READ_PAYLOAD */\n          ;\n        } else {\n          if (totalLength(chunks) < expectedLength) {\n            break;\n          }\n\n          var data = concatChunks(chunks, expectedLength);\n          controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n          state = 0\n          /* READ_HEADER */\n          ;\n        }\n\n        if (expectedLength === 0 || expectedLength > maxPayload) {\n          controller.enqueue(ERROR_PACKET);\n          break;\n        }\n      }\n    }\n  });\n}\nexport var protocol = 4;\nexport { encodePacket, encodePayload, decodePacket, decodePayload };","map":null,"metadata":{},"sourceType":"module"}